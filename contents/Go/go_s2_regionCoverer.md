# Google S2 中的 priorityQueue 优先队列和 LCA 最近公共祖先


## 寻找父亲节点和叶子节点

首先需要回顾一下希尔伯特曲线的生成方式，具体代码见笔者[上篇文章的分析](https://github.com/halfrost/Halfrost-Field/blob/master/contents/Go/go_spatial_search.md#5-坐标轴点与希尔伯特曲线-cell-id-相互转换)，在这个分析中，有4个方向比较重要，接下来的分析需要，所以把这4个方向的图搬过来。

![](http://upload-images.jianshu.io/upload_images/1194012-f67519dd4959f298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


在举例之前还需要说明一点，有些网站提供的二进制转换，并没有标明有符号还是无符号的转换，这样就会导致使用者的一些误解。笔者开始并没有发现这个问题，导致掉入了这个坑，好一会才转过弯来。笔者在网上查询了很多在线转换计算器的工具，都发现了这个问题。比如常见的[在线进制转换http://tool.oschina.net/hexconvert](http://tool.oschina.net/hexconvert)，随便找两个64位的二进制数，有符号的和无符号的分别转换成十进制，或者反过来转换，你会惊喜的发现，两次结果居然相同！例如你输入 3932700003016900608 和 3932700003016900600，你会发现转换成二进制以后结果都是 11011010010011110000011101000100000000000000000000000000000000。但是很明显这两个数不同。

假如 3932700003016900608 是无符号的，3932700003016900600 是有符号的，正确的结果应该如下：

```go

// 3932700003016900608
11011010010011110000011101000100000000000000000000000000000000

// 3932700003016900600
11011010010011110000011101000011111111111111111111111111111000

```

差距明显很大。这种例子其实还有很多，随便再举出几组：无符号的 3932700011606835200 和有符号的 3932700011606835000；无符号的 3932700020196769792 和有符号的 3932700020196770000；无符号的 3932700028786704384 和有符号的 3932700028786704400……可以举的例子很多，这里就不再举了。总之这些工具都是按照无符号去转换的。

好了，进入正题。接下来直接看一个例子，笔者用例子来说明每个 cell 之间的关系，以及如何查找父亲节点的。


![](http://upload-images.jianshu.io/upload_images/1194012-8cba180aedc07d89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

假设有上图这4个连在一起的 cell。先根据经纬度把 cellID 计算出来。


![](http://upload-images.jianshu.io/upload_images/1194012-d3b9e286a13e56d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

对应的4个 cellID 分别是：

```go

// 3932700003016900608 右上
11011010010011110000011101000100000000000000000000000000000000      

// 3932700011606835200 左上
11011010010011110000011101001100000000000000000000000000000000 

// 3932700020196769792 左下
11011010010011110000011101010100000000000000000000000000000000

// 3932700028786704384 右下
11011010010011110000011101011100000000000000000000000000000000


```

在前篇文章里面我们也分析了 Cell 64位的结构，这里是4个 Level 14的 Cell，所以末尾有 64 - 3 - 1 - 14 * 2 = 32 个 0 。从末尾往前的第33位是一个1，第34位，第35位是我们重点需要关注的。可以看到分别是00，01，10，11 。正好是连续的4个二进制。

![](http://upload-images.jianshu.io/upload_images/1194012-f67519dd4959f298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

根据这个顺序，我们可以匹配到当前这4个 Level 14 的 Cell 对应的顺序是上图图中的图1 。只不过当前方向旋转了45°左右。


![](http://upload-images.jianshu.io/upload_images/1194012-ee49299619d6c5cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





## LCA 查找最近公共祖先


覆盖的区域是球面上的盘子区域

低等级的 level 的 cell 会优先使用。即大格子会优先使用。

关于 MaxCells 的设置，如果是所需的最小的单元数，就返回最小的单元数。如果待覆盖的区域正好位于三个立方体的交点处，那么就要返回3个 cell，即使覆盖的面会比要求的大一些。

如果设置的单元格的最小 cell 的 level 太高了，即格子太小了，那么就会返回任意数量的单元格数量。

如果 MaxCells 小于4，即使该区域是凸的，比如 cap 或者 rect ，最终覆盖的面积也要比原生区域大。

这个近似算法并不是最优算法，但是在实践中效果还不错。输出的结果并不总是使用的满足条件的最多的单元数，因为这样也不是总能产生更好的近似结果(比如上面举例的，区域整好位于三个面的交点处，得到的结果比原区域要大很多) 并且 MaxCells 对搜索的工作量和最终输出的 cell 的数量是一种限制。


由于这是一个近似算法，所以不能依赖它输出的稳定性。特别的，覆盖算法的输出结果会在不同的库的版本上有所不同。

这个算法还可以产生内部覆盖的 cell，内部覆盖的 cell 指的是完全被包含在区域内的 cell。

如果没有满足条件的 cell ，即使对于非空区域，内部覆盖 cell 也可能是空的。

请注意，处于性能考虑，在计算内部覆盖 cell 的时候，指定 MaxLevel 是明智的做法。否则，对于小的或者零面积的区域，算法可能会花费大量时间将单元格细分到叶子 level ，以尝试找到满足条件的内部覆盖单元格 cell。