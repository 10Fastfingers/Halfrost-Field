# 如何设计并实现一个线程安全的 Map ？(下篇)

<p align='center'>
<img src='http://upload-images.jianshu.io/upload_images/1194012-a09c131eb02323fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240'>
</p>






在上篇中，我们已经讨论过如何去实现一个 Map 了，并且也讨论了诸多优化点。在下篇中，我们将继续讨论如何实现一个线程安全的 Map。说到线程安全，需要从概念开始说起。


![](http://upload-images.jianshu.io/upload_images/1194012-a50cce475fe9b0b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



线程安全就是如果你的代码块所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。

如果代码块中包含了对共享数据的更新操作，那么这个代码块就可能是非线程安全的。但是如果代码块中类似操作都处于临界区之中，那么这个代码块就是线程安全的。


通常有以下两类避免竞争条件的方法来实现线程安全：

#### 第一类 —— 避免共享状态

1. 可重入 [Re-entrancy](https://en.wikipedia.org/wiki/Reentrant_(subroutine)) 

通常在线程安全的问题中，最常见的代码块就是函数。让函数具有线程安全的最有效的方式就是使其可重入。如果某个进程中所有线程都可以并发的对函数进行调用，并且无论他们调用该函数的实际执行情况怎么样，该函数都可以产生预期的结果，那么就可以说这个函数是可重入的。

如果一个函数把共享数据作为它的返回结果或者包含在它返回的结果中，那么该函数就肯定不是一个可重入的函数。任何内含了操作共享数据的代码的函数都是不可重入的函数。

为了实现线程安全的函数，把所有代码都置放于临界区中是可行的。但是互斥量的使用总会耗费一定的系统资源和时间，使用互斥量的过程总会存在各种博弈和权衡。所以请合理使用互斥量保护好那些涉及共享数据操作的代码。

**注意**：可重入只是线程安全的充分不必要条件，**并不是充要条件**。这个反例在下面会讲到。

2. 线程本地存储

如果变量已经被本地化，所以每个线程都有自己的私有副本。这些变量通过子程序和其他代码边界保留它们的值，并且是线程安全的，因为这些变量都是每个线程本地存储的，即使访问它们的代码可能被另一个线程同时执行，依旧是线程安全的。

3. 不可变量

对象一旦初始化以后就不能改变。这意味着只有只读数据被共享，这也实现了固有的线程安全性。可变（不是常量）操作可以通过为它们创建新对象，而不是修改现有对象的方式去实现。 Java，C＃和Python 中的字符串的实现就使用了这种方法。


#### 第二类 —— 线程同步

第一类方法都比较简单，通过代码改造就可以实现。但是如果遇到一定要进行线程中共享数据的情况，第一类方法就解决不了了。这时候就出现了第二类解决方案，利用线程同步的方法来解决线程安全问题。

今天就从线程同步开始说起。



---------------------------------------------


## 一. 线程同步理论

在多线程的程序中，多以共享数据作为线程之间传递数据的手段。由于一个进程所拥有的相当一部分虚拟内存地址都可以被该进程中所有线程共享，所以这些共享数据大多是以内存空间作为载体的。如果两个线程同时读取同一块共享内存但获取到的数据却不同，那么程序很容易出现一些 bug。

为了保证共享数据一致性，最简单并且最彻底的方法就是使该数据成为一个不变量。当然这种绝对的方式在大多数情况下都是不可行的。比如函数中会用到一个计数器，记录函数被调用了几次，这个计数器肯定就不能被设为常量。那这种必须是变量的情况下，还要保证共享数据的一致性，这就引出了临界区的概念。


![](http://upload-images.jianshu.io/upload_images/1194012-ca316bda95dfa59a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


临界区的出现就是为了使该区域只能被串行的访问或者执行。临界区可以是某个资源，也可以是某段代码。保证临界区最有效的方式就是利用线程同步机制。


先介绍2种共享数据同步的方法。


### 1. 互斥量

在同一时刻，只允许一个线程处于临界区之内的约束称为互斥，每个线程在进入临界区之前，都必须先锁定某个对象，只有成功锁定对象的线程才能允许进入临界区，否则就会阻塞。这个对象称为互斥对象或者互斥量。


一般我们日常说的互斥锁就能达到这个目的。

互斥量可以有多个，它们所保护的临界区也可以有多个。先从简单的说起，一个互斥量和一个临界区。

#### (一) 一个互斥量和一个临界区



#### (二) 多个互斥量和一个临界区


#### (三) 多个互斥量和多个临界区



### 2. 条件变量



## 二. 简单的线程锁方案

大量的利用了 volatile，final，CAS 等lock-free技术来减少锁竞争对于性能的影响。


## 三. 现代线程安全的 Lock - Free 方案 CAS


## 四. ABA 问题


## 五. Lock - Free方案举例



## 五. 性能对比


## 六. 总结





```go

type Map struct {
	mu Mutex
	// 并发读取 map 中一部分的内容是线程安全的，这是不需要
	// 读取的部分自身就是线程安全的，但是 Mutex 信号量的值还是需要存储
	// entry 在并发读取过程中是允许更新的，即使没有 Mutex 信号量，但是更新一个以前删除的 entry 就需要把值拷贝到 dirty Map 中，并且必须要带上 Mutex
	// 只读
	read atomic.Value // readOnly

	// dirty 包含一部分 mutex 持有的 map 数据，为了提高 dirty map 读取速度，它包含了所有没有删除的 entry。已经删除的 entry 不存储在 dirty 中，存储在 clean map 中。
	// 如果 dirty map 是 nil，下一次要写入该 map 的时候将会用 clean map 的浅拷贝初始化它，并忽略掉一些旧的 entry
	dirty map[interface{}]*entry

	// misses 记录了 read map 最后更新的次数，为此需要锁住 mutex 去判断 key 是否出现了。
	// 一旦 misses 值足够去复制 dirty map ，那么 dirty map 就被提升到未被修改状态下的 read map，下次存储就会创建一个新的 dirty map。
	misses int
}

```







------------------------------------------------------

Reference：  
《Go 并发实战编程》     
[Split-Ordered Lists: Lock-Free Extensible Hash Tables](http://people.csail.mit.edu/shanir/publications/Split-Ordered_Lists.pdf)   
[Semaphores are Surprisingly Versatile](http://preshing.com/20150316/semaphores-are-surprisingly-versatile/)


> GitHub Repo：[Halfrost-Field](https://github.com/halfrost/Halfrost-Field)
> 
> Follow: [halfrost · GitHub](https://github.com/halfrost)
>
> Source: [https://halfrost.com/go\_map\_chapter\_two/](https://halfrost.com/go_map_chapter_two/)